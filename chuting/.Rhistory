knitr::opts_chunk$set(echo = TRUE)
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
save(bins_list, example_cov, expression, file="chuting/data/example_data.rda")
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
save(bins_list, example_cov, expression, file="C:\Users\yiziw\OneDrive\Documents\Genetic-Data-Analysis\chuting\Data")
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
# If your working directory is set to the project's root directory
save(bins_list, example_cov, expression, file="chuting/data/example_data.rda")
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
# If your working directory is set to the project's root directory
save(bins_list, example_cov, expression, file="C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting/data/example_data.rda")
devtools::use_vignette("chutingVignette")
knitr::opts_chunk$set(echo = TRUE)
devtools::use_vignette("chutingVignette")
library(usethis)
devtools::use_vignette("chutingVignette")
devtools::use_vignette("chutingVignette")
devtools::use_vignette("chutingVignette")
library(usethis)
devtools::use_vignette("chutingVignette")
library(usethis)
usethis::use_vignette("chutingVignette")
library(chuting)
# Load the package containing the two functions: mean_bin_signal() and find_best_bin_fixed_pc()
library(chuting)
devtools::document("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
devtools::build("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
devtools::document("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
devtools::build("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
# If your working directory is set to the project's root directory
# Within your R session:
save(bins_list, file="chuting/data/bins_list.rda")
library(GenomicRanges)
library(IRanges)
library(S4Vectors)
mean_bin_signal <- function(bins, cov) {
bins_by_chr <- split(bins, seqnames(bins))
result <- numeric(length(bins))
start_idx <- 1
for (chr in names(bins_by_chr)) {
chr_bins <- bins_by_chr[[chr]]
if (!chr %in% names(cov)) {
# Chromosome not found in coverage
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
chr_cov <- cov[[chr]]
chr_bins <- trim(chr_bins)
if (length(chr_bins) == 0) {
# No bins after trimming
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- NA
start_idx <- end_idx + 1
next
}
v <- Views(chr_cov, start=start(chr_bins), end=end(chr_bins))
means <- viewMeans(v)
if (length(means) == 0) means <- rep(NA, length(chr_bins))
end_idx <- start_idx + length(chr_bins) - 1
result[start_idx:end_idx] <- means
start_idx <- end_idx + 1
}
result
}
set.seed(123)
num_genes <- 5
num_bins <- 10
bin_width <- 100
bins_list <- vector("list", num_genes)
for (g in seq_len(num_genes)) {
start_bin <- (g-1)*(num_bins*bin_width) + 1
end_bin <- g*(num_bins*bin_width)
bin_starts <- seq(start_bin, end_bin, by=bin_width)
bin_ends <- bin_starts + bin_width - 1
bins_list[[g]] <- GRanges(
seqnames = Rle("chr1"),
ranges = IRanges(start=bin_starts, end=bin_ends),
strand = Rle("*")
)
}
total_length <- num_genes * num_bins * bin_width
cov_chr1 <- Rle(runif(total_length, 0, 10))
example_cov <- list(chr1=cov_chr1)
# Expression depends strongly on bin #5
temp_signals_list <- lapply(bins_list, mean_bin_signal, cov=example_cov)
signal_matrix_temp <- do.call(rbind, temp_signals_list)
expression <- 2 * signal_matrix_temp[,5] + rnorm(num_genes, 0, 0.5)
dir.create("chuting/data", showWarnings=FALSE)
# If your working directory is set to the project's root directory
# Within your R session:
save(bins_list, file="C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting/data/bins_list.rda")
save(example_cov, file="C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting/data/example_cov.rda")
save(expression, file="C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting/data/expression.rda")
devtools::document("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
devtools::build("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
devtools::install("C:/Users/yiziw/OneDrive/Documents/Genetic-Data-Analysis/chuting")
library(chuting)
# Load the package containing the two functions: mean_bin_signal() and find_best_bin_fixed_pc()
library(chuting)
# Load the sample data included in the package:
# bins_list: A list of GRanges objects, each representing bins for one gene.
# example_cov: A coverage object (list of Rle) keyed by chromosome.
# expression: A numeric vector of expression values, one per gene.
data("bins_list")
data("example_cov")
data("expression")
# Let's check how many genes we have:
length(bins_list)    # Number of genes in the dataset.
# Inspect the first few expression values to understand the range and data:
head(expression)      # First few expression values for the genes.
# Choose one gene (the first gene) to demonstrate mean_bin_signal():
gene1_bins <- bins_list[[1]]
# Compute the mean coverage for each bin of this first gene:
# mean_bin_signal takes the bins (GRanges) and the coverage (example_cov) and returns mean coverage per bin.
gene1_signals <- mean_bin_signal(gene1_bins, example_cov)
gene1_signals  # Display the mean signals
# Now use find_best_bin_fixed_pc() to identify which bin is best correlated with expression across all genes:
# This function:
# 1. Computes mean signals for all genes using mean_bin_signal().
# 2. Adds a fixed pseudocount (0.1) and applies log2 transformation.
# 3. Correlates each bin's coverage profile with the expression vector.
# 4. Returns the bin with the highest absolute correlation.
result <- find_best_bin_fixed_pc(example_cov, bins_list, expression)
# The result is a list containing:
# $pseudocount: The fixed pseudocount used (0.1).
# $best_bin: The index of the best-correlated bin.
# $correlations: A vector of correlation values for each bin.
result
